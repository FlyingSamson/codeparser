docs: stages of parser





bytes

-> decode bytes ->

Source characters

-> decode Source characters ->

WL characters

-> tokenize ->

tokens

-> parse ->

concrete nodes

-> aggregate ->

aggregate nodes

-> abstract ->

abstract nodes













different levels of syntax



# boxes

RowBox[{"1", "+", RowBox[{"(*", "*)"}], "a"}]

RowBox[{"1", "+", RowBox[{"(*", "*)"}], SqrtBox["a"]}]

tree structure of tokens

no type information

no fake tokens

comments are kept

whitespace is kept

newlines are kept







# concrete

InfixNode[Plus, {
	LeafNode[Integer, "1", <||>],
	LeafNode[Token`Plus, "+", <||>],
	LeafNode[Token`Comment, "(**)", <||>],
	LeafNode[Symbol, "a", <||>] }, <||>]

InfixNode[Plus, {
	LeafNode[Integer, "1", <||>],
	LeafNode[Token`Plus, "+", <||>],
	LeafNode[Token`Comment, "(**)", <||>],
	LeafNode[SqrtBox, "a", <||>] }, <||>]

comments are kept

whitespace is kept

newlines are kept

type information is added
type information is the wrapper like InfixNode[Plus, ...]

and also type information is all of the riffled tokens InfixNode[Plus, { 1, +, 2, \[ImplicitPlus], 3 }]



fake tokens are added




when parsing   ;;   it is convenient to remember the implicit   1 ;; All

when parsing a; ;  it is convenient to remember the implicit a ; Null ; Null



implicit Times

when parsing   a b   it is convenient to remember the implicit   a ImplicitTimes b



empty string error:


when parsing   a::

mark it as a::EmptyStringError




EOF

when parsing   a @

mark it as a @ EOF















# aggregate

InfixNode[Plus, {
	LeafNode[Integer, "1", <||>],
	LeafNode[Token`Plus, "+", <||>],
	LeafNode[Symbol, "a", <||>] }, <||>]

InfixNode[Plus, {
	LeafNode[Integer, "1", <||>],
	LeafNode[Token`Plus, "+", <||>],
	LeafNode[SqrtBox, "a", <||>] }, <||>]

type information is kept

fake tokens are kept

comments are removed

whitespace is removed

newlines are removed












# abstract

CallNode[LeafNode[Symbol, "Plus", <||>], {
				LeafNode[Integer, "1", <||>],
				LeafNode[Symbol, "a", <||>] }, <||>]

CallNode[LeafNode[Symbol, "Plus", <||>], {
				LeafNode[Integer, "1", <||>],
				LeafNode[SqrtBox, "a", <||>] }, <||>]

everything is a Call

type information is lost because everything is a CallNode

fake tokens are converted to actual tokens











